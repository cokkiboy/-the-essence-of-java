<h1>-the-essence-of-java-ch7-</h1>
<h2>inheritance(상속)</h2>
상속이란,기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것이다. 상속을 통해서 클래스를 작성하면 보다 적은 양의 코드로 새로운 클래스를 작성할 수있고 코드를 공통적으로 관리할수 있기 때문에 코드의 추가및 변경이 매우용이하다.<br>
이러한 특징은 코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 크게 기여한다.<br>
자바에서 상속을 구현하는 방법은 아주 간단하다. 새로 작성하고자 하는 클래스의 이름 뒤에 상속받고자 하는 클래스의 이름을 키워드'extends'와 함께 써주기만 하면된다.<br>
예를 들어 새로 작성하려는 클래스의 이름이 Child이고 상속받고자 하는 기존 클래스의 이름이 Parent라면 다음과 같이하면된다<br>
class Child(자손클래스),(sub class) extends Parent(조상클래스),상위(super)클래스{
}
<h2>overriding</h2>
<h3> 오버라이딩이란</h3>
조상 클래스로부터 상속받은 메서드의 내용을 변경하는 것을 오버라이딩이라고한다. 상속받은 메서드를 그대로 사용하기도 하지만. 자손 클래스 자신에 맞게 변경해야하는경우가 많다.
이럴떄 조상의 메서드를 오버라이딩한다.</br>

class Point{
  int x;
  int y;<br>
 <br> String getLocation(){
      return "x:"+x+",y:"+y;
  }
}
class Point3D extends Point{
 int z;
  String  getLocation(){
      return "x:"+x+",y:"+y+",z:"+z;
  }
}<br>
Point클래스의 getLocation() 은 한점의 x,y좌표를 문자열로 반환하도록 작성 되었다.<br>
이 두클래스 는 서로 상속관계에 있으므로Point3D클래스는 Point클래스로부터 getLocation()을 상속받지만,Point3D클래스 는 3차원 좌표계의 한점을 표현하기 위한 것이다. 그래서 이메서드를 Point3D클래스 자신에 맞게 z축의 좌표값도 포함하여 반환하도록 오버라이딩 하였다.<br>
Point클래스를 사용하던 사람들은  새로 작성된 Point3D 클래스가 Point 클래스의 자손이므로 Point3D의 인스턴스에 getLocaion()을 호출하면 Point클래스의 getLocation()이 그랬듯이 점의 좌표를 문자열로 얻을 수 있을거락 기대할 것이다. 그렇기 떄문에 새로운 메서드를 제공하는 것보다 오버라이딩을 하는것이 바른 선택이다 

<h2>오버라이딩 조건</h2>
<h3>자손클래스에서 오버라이딩하는 메서드는 조상 클래스의 매서드 와<h3>

1.이름이 같아야한다<br>
2.매개변수가 같아야한다<br>
3.반환타입이 같아야한다<br>
4.접근 제어자는 조상 클래스의 메서드보다 좁은 범위로 변경할수없다.
  public > protected>(default)>private
  <h4> 조상클래스의 매서드를 자손 클래스에서 오버라이딩할때 </h4>
  1.접근제어자를 조상클래스의 메서드보다 좁은 범위로 변경할 수없다.<br>
  2.예외는 조상 클래스의 메서드보다<br>
  3.인스턴스 메서드를 static메서드로 또는 그반대로 변경 할수 없다.</br>
  <h2>오버로딩 vs오버라이딩</h2>
  오버로딩(overloading)기존에 없는 새로운 메서드를 정의하는 것
  오버라이딩(overriding)상속받은 메서드의 내용을 변경하는 것
  <h3>super<h3>
super는 자손클래스에서 조상 클래스로부터 상속받은 멤버를 참조하는데 사용되는 참조 변수이다. 멤버변수와 지역변수으 이름이 같을떄 this를 붙여서 구별했듯이 상속받은 멤버 와자신의 멤버와 이름이 같을 떄는 super를 붙여서 구별할 수있다.<br></br>
조상 클래스로부터 상속받은 멤버도 자손 클래스 자신의 멤버이므르 super 대신 this를 사용할수있다. 그래도 조상 클래스의 멤버와 자손 클래스의 멤버가 중복정의되어 서로 구별해야하는 경우에만 super를 사용하는 것이좋다.
    조상의 멤버와 자신의 멤버를 구별하는데 사용된다는 점을 제외하고는 super 와 this는 근본적으로 같다. 모든 인스턴스메서드에는 자신이 속한 인스턴스의 주소가 지역변수로 저장되는데, 이것이 참조변수인 this와 super의 값이 된다.<br></br>
  static메서드(클래스메서드)는 인스턴스와 관련이 없다. 그래서 this 와미친가지로 super역시static메서드에서는 사용할 수없고 인스턴스메서드에서만 사용할 수있다.
  <h3>super()-조상 클래스의 생성자</h3>
  this() 와마친가지로 super() 역시 생성자이다. this()는 같은 클래스의 다른 생성자를 호출하는데 사용되지만,super()는 조상클래스의 생성자를 호출하는데 사용된다.<br></br>
  자손 클래스의 인스턴스를 생성하면 , 자손의 멤버와 조상의 멤버가  모두 합쳐진 하나의 인스턴스가 생성된다. 그래서 자손클래스의 인스턴스가 조상 클래스의 멤버들을 사용할수있는 것이다. 이때 조상 클래스 멤버의 초기화 작업이 수행되어야 하기 떄문에 자손클래스의 생성자에서 조상 클래스의 생성자가 호출되어야한다</br>
   생성자의 첫 줄에서  조상클래스의 생성자를 호출해야하는 이유는 자손 클래스의 멤버가 조상 클래스의 멤버를 사용할수도 있으므로 조상의 멤버들이 먼저 초기화되어 있어야하기 떄문이다.<br>
   이와 같은 조상 클래스 생성자의 호출 은 클래스의 상속관계를 거슬러 올라가면서 계속 반복된다. 마지막으로 모든 클래스의 최고 조상인 Object클래스의 생성자인 Object() 까지 가서야 끝난다.
  <h2> 추상 클래스 (abstract class)</h2>
   1.미완성 클래스<br>
   2.객체생성 불가<br>
   3.객체를 생성하기위해서 상속을 통해서 sub class로 객체 생성가능<br>
   <h3>인터페이스(interface)<h3>
    1.인터페이스 추상클래스 중하나<br>
    2.자바는 다중상속이안되는데 인터페이스를 통해서 다중상속이가능<br>
    3. 인터페이스를 상속할떄 extends 아닌 implements 사용한다
  
